## 响应式编程

### 概览

- 本章将介绍响应式编程并讲解 **LiveData** 和 **Flow** 组件的原理以及使用

### 生产者 - 消费者

- 通常负责从本地数据库或远程数据库获取数据的组件我们称之为**生产者**，而使用数据并进行“展示”等操作的组件我们称之为**消费者**
- 在传统的架构模式下，我们总是习惯于在我们需要的时候通知生产者进行**生产**数据，利用接口回调的方式，处理数据然后将结果用于消费者的**消费**行为
- 不过，这种传统的“生产-消费”模式往往会将**数据操作**、**逻辑操作**以及**UI操作**耦合，当项目变得稍微庞大一些，或者想要修改陈旧代码的时候往往会变得十分困难，甚至在不同数据需要互相组合调用的时候更容易写出BUG

### 什么是响应式编程

- 响应式编程巧妙地解决了上面的问题，我们通过在 生产者 - 消费者 当中添加一个“中介”负责管理数据的存储与分发，我们称这个中介为 **可观察数据** 或 **响应式数据**
- 生产者生产的数据可以存放到这个可观察数据中，消费者可以通过**观察者**订阅这个可观察数据，生产者/消费者 与可观察数据的关系是多对多的，每当因生产者生产行为导致可观察数据的值改变，可观察数据（通常情况下）会立即调用所有其观察者中的回调函数以供消费者进行消费

### LifecycleOwner

- LifecycleOwner是一个接口，通过 `LifecycleOwner#getLifecycle():LifeCycle` ，可以获取到Lifecycle对象
- Lifecycle定义一个具有 Android 生命周期的对象，通过`Lifecycle#getCurrentState():State`，可以获取到当前生命周期的状态，如 **ON_CREATE**，**ON_START** 等

### Observer

- Observer是一个 **SAM接口** ，是一个可以从 LiveData 接收数据的简单回调

### LiveData

- LiveData 是一个可以在给定生命周期内观察到的数据持有者类。这意味着Observer可以与LifecycleOwner成对添加，并且只有当配对的 LifecycleOwner 处于活动状态时，才会通知该观察者有关包装数据的修改。

- 在Android中，**ComponentActivity** 以及 **Fragment** 都已默认实现了LifecycleOwner接口

    ```kotlin
    // data.source.MessageDataSource (生产者)
    class MessageDataSource {
        // ...
        fun getMessage(): String {
            return mockApi.getMessage()
        }
    }
    ```

    ```kotlin
    // ui.MessageViewModel (存放可观察数据)
    class MessageViewModel(
    	private val dataSource: MessageDataSource
    ) :ViewModel() {
        // MutableLiveData是LiveData的子类，其拥有改变其持有数据的API
        val messageLiveData = MutableLiveData<String>()
        fun getMessge() {
            // 同步方式改变其持有数据：MutableLiveData.setValue<T>(T)
            // 异步方式改变其持有数据：MutableLiveData.postValue<T>(T)
            messageLiveData.value = dataSource.getMessage()
        }
    }
    ```

    ```kotlin
    // ui.MessageActivity (消费者)
    class MessageActivity :AppCompatActivity() {
        private val viewModel by viewModels<MessageViewModel>()
        private lateinit var textView: TextView
        private lateinit var button: Button
        override fun onCreate(savedInstanceState:Bundle?){
            // 订阅此数据：LiveData.observe(LifecycleOwener,Observer)
            viewModel.messageLiveData.observe(this) {
                textView.text = it
            }
            button.setOnClickListener {
                // 触发数据获取操作
                viewModel.getMessage()
            }
        }
    }
    ```

    
